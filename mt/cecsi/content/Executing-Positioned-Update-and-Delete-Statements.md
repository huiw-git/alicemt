---
title: Executing Positioned Update and Delete Statements
ms.custom: na
ms.date: 07/12/2016
ms.prod: sql-non-specified
ms.reviewer: na
ms.suite: na
ms.technology: 
  - drivers
ms.tgt_pltfrm: na
ms.topic: article
ms.assetid: 1d64f309-2a6e-4ad1-a6b5-e81145549c56
manager: jhubbard
translation.priority.ht: 
  - en-gb
---
# Executing Positioned Update and Delete Statements
<?xml version="1.0" encoding="utf-8"?>
<developerReferenceWithoutSyntaxDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://ddue.schemas.microsoft.com/authoring/2003/5 http://dduestorage.blob.core.windows.net/ddueschema/developer.xsd">
  <introduction>
    <alert class="important">
      <para>This feature will be removed in a future version of Windows. Avoid using this feature in new development work and plan to modify applications that currently use this feature. Microsoft recommends using the driver's cursor functionality.</para>
    </alert>
    <para>After an application has fetched a block of data with <legacyBold>SQLFetchScroll</legacyBold>, it can update or delete the data in the block. To execute a positioned update or delete, the application:  </para>
    <list class="ordered">
      <listItem>
        <para>Calls <legacyBold>SQLSetPos</legacyBold> to position the cursor on the row to be updated or deleted.</para>
      </listItem>
      <listItem>
        <para>Constructs a positioned update or delete statement with the following syntax: </para>
        <para>     <legacyBold>UPDATE</legacyBold> <legacyItalic>table-name</legacyItalic></para>
        <para>          <legacyBold>SET </legacyBold><legacyItalic>column-identifier</legacyItalic> <legacyBold>=</legacyBold> {<legacyItalic>expression</legacyItalic> | <legacyBold>NULL</legacyBold>} </para>
        <para>          [<legacyBold>, </legacyBold><legacyItalic>column-identifier</legacyItalic> <legacyBold>=</legacyBold> {<legacyItalic>expression</legacyItalic> | <legacyBold>NULL</legacyBold>}] </para>
        <para>          <legacyBold>WHERE CURRENT OF </legacyBold><legacyItalic>cursor-name</legacyItalic></para>
        <para>     <legacyBold>DELETE FROM</legacyBold> <legacyItalic>table-name</legacyItalic> <legacyBold>WHERE CURRENT OF </legacyBold><legacyItalic>cursor-name</legacyItalic></para>
        <para>The easiest way to construct the <legacyBold>SET</legacyBold> clause in a positioned update statement is to use parameter markers for each column to be updated and use <legacyBold>SQLBindParameter</legacyBold> to bind these to the rowset buffers for the row to be updated. In this case, the C data type of the parameter will be the same as the C data type of the rowset buffer. </para>
      </listItem>
      <listItem>
        <para>Updates the rowset buffers for the current row if it will execute a positioned update statement. After successfully executing a positioned update statement, the cursor library copies the values from each column in the current row to its cache. </para>
        <alert class="caution">
          <para>If the application does not correctly update the rowset buffers before executing a positioned update statement, the data in the cache will be incorrect after the statement is executed.</para>
        </alert>
      </listItem>
      <listItem>
        <para>Executes the positioned update or delete statement using a different statement than the statement associated with the cursor. </para>
        <alert class="caution">
          <para>The <legacyBold>WHERE</legacyBold> clause constructed by the cursor library to identify the current row can fail to identify any rows, identify a different row, or identify more than one row. For more information, see <legacyLink xlink:href="e429254c-c43f-4fbf-98b2-5f1ed53501ff">Constructing Searched Statements</legacyLink>.</para>
        </alert>
      </listItem>
    </list>
    <para>All positioned update and delete statements require a cursor name. To specify the cursor name, an application calls <legacyBold>SQLSetCursorName</legacyBold> before the cursor is opened. To use the cursor name generated by the driver, an application calls <legacyBold>SQLGetCursorName</legacyBold> after the cursor is opened.</para>
    <para>After the cursor library executes a positioned update or delete statement, the status array, rowset buffers, and cache maintained by the cursor library contain the values shown in the following table.</para>
    <table xmlns:caps="http://schemas.microsoft.com/build/caps/2013/11">
      <thead>
        <tr>
          <TD>
            <para>Statement used</para>
          </TD>
          <TD>
            <para>Value in row status array</para>
          </TD>
          <TD>
            <para>Values in</para>
            <para>rowset buffers</para>
          </TD>
          <TD>
            <para>Values in</para>
            <para>cache buffers</para>
          </TD>
        </tr>
      </thead>
      <tbody>
        <tr>
          <TD>
            <para>Positioned update</para>
          </TD>
          <TD>
            <para>SQL_ROW_UPDATED</para>
          </TD>
          <TD>
            <para>New values[1]</para>
          </TD>
          <TD>
            <para>New values[1]</para>
          </TD>
        </tr>
        <tr>
          <TD>
            <para>Positioned delete</para>
          </TD>
          <TD>
            <para>SQL_ROW_DELETED</para>
          </TD>
          <TD>
            <para>Old values</para>
          </TD>
          <TD>
            <para>Old values</para>
          </TD>
        </tr>
      </tbody>
    </table>
    <para>[1]   The application must update the values in the rowset buffers before executing the positioned update statement; after executing the positioned update statement, the cursor library copies the values in the rowset buffers to its cache.</para>
  </introduction>
  <relatedTopics />
</developerReferenceWithoutSyntaxDocument>